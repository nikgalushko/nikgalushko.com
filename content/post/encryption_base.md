+++
author = "Nikita Galushko"
title = "Краткий курс по шифрованию: симметричное шифрование"
date = "2024-01-01"
description = "Краткий курс по шифрованию: симметричное шифрование"
tags = [
    "go",
    "база",
    "шифрование",
    "ChaCha20", "AES",
]
categories = [
    "go",
    "база",
    "шифрование",
]
+++

Первая часть кратких заметок по шифрованию. В этой части будет затронута "база" aka симметричное шифрование. Ответим на вопросы какие алгоритмы существуют, какие стоит использовать, а про какие нужно забыть; чем блочные шифры отличаются от потоковых; и что за странные буквы GCM, CTR, CBC.

## 0 Что это?

Решил собрать все свои знания по шифрованию с точки зрения практики в нескольких коротких заметках. Никакой сложной математики не будет, строго практический подход: что, для чего и как нужно использовать. Поговорим про симметричное, ассиметричное шифрование, что такое MAC и HMAC, цтфровые подписи. А в финальной заметке затронем острие прогресса (на момент написания этих заметок) под названием zkSNARKs.

## Симметричное шифрование

Немного теории в начале все же придется дать :)

**Симметричное шифрование** -- такой вид шифрования, при котором для шифрования и разшифрования используется один и тот же ключ, то есть секретный ключ должен быть и как у отправителя сообщения, который шифрует его, так и у получателя, которому придется его расшифровывать.

Симметричное шифрование делится на две категории:
- **блочные шифры** -- оперируют блокам про шифровании, разбивая шифруемые данные на блоки заданной длинны, если последий блок данных меньше заданного размера, то он заполняется байтами до недостающей длинны
- **потоковые шифры** -- оперируют не блоками, а отдельными байтами

Потоковые шифры работают быстрее блочных, но при этом их стойкость ниже.

### Что такое стойкость и как она определяется

Криптографически стойкими называют такие алгоритмы взлом которых вычислительно недостижим. Простыми словами это означает, что для того, чтобы взломать такой алгоритм нужно невероятно много ресурсов (процессора, памяти), которых просто нет в нашем мире.

- - - -

Тут нужно сделать ремарку на счет постквантового мира. Сейчас популярные алгоритмы исходят из того, как устроена работа текущего поколения вычислительных машин. Создание полноценного квантового компьютера изменит положение дел в мире криптографии. Потенциально бОльшая часть подходов к криптографии станет не безопасной. Умные люди уже работают над созданием постквантовыми алгоритмами шифрования. Так что stay tuned :)

- - - -

Стойкость криптографических алгоритмов измеряетя в битах и означает, что для того, чтобы взломать шифр нужно выполнить 2^N операций, где N как раз количество бит стойкости.

## Какие алгоритмы стоит использовать

Не буду писать про все все все существующие алгоритмы симметричного шифрования. Отмечу лишь два как самых популярных и современных.

Если вам нужен блочный шифр, то ваш выбор **AES** и точка! Забудьте про всякие старые и вонючие DES.

Если нужен потоковый шифр, то выбор должен упасть в сторону **ChaCha20**. Единственное у этого адгоритма есть некоторое ограничение -- с его помощью за раз можно шифровать только 256Гб данных, потому что внутри используется 32-битный счетчик блоков. Если придется шифровать данные бОльшего размера, то стоит задуматься о том, как вы будете сбрасывать этот счетчик и менять начальное одноразовое число.

## Режимы работы блочных шифров

Если мы попробуем найти на github или где-то еще пример как на Go зашифровать текст при помощи AES, то наткнемся примерно на вот такой код:

```go
import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/base64"
	"io"
	"fmt"
)

var (
	text = []byte("Never gonna give you up\nNever gonna let you down")
	key = []byte("passphrasewhichneedstobe32bytes!")
)

func gcmEncrypt() {
   c, err := aes.NewCipher(key)
   if err != nil {
       panic(err)
   }

   gcm, err := cipher.NewGCM(c)
   if err != nil {
       panic(err)
   }

   nonce := make([]byte, gcm.NonceSize())
   if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
       fmt.Println(err)
   }

   fmt.Println(gcm.Seal(nonce, nonce, text, nil))
}
```

или даже на вот такой:

```go
func cbcEncrypt() {
	block, err := aes.NewCipher(key)
	if err != nil {
		panic(err)
	}

	cipherText := make([]byte, aes.BlockSize+len(text))
	iv := cipherText[:aes.BlockSize]
	if _, err = io.ReadFull(rand.Reader, iv); err != nil {
		panic(err)
	}

	stream := cipher.NewCBCEncrypter(block, iv)
	stream.CryptBlocks(cipherText[aes.BlockSize:], byteMsg)

	fmt.Printlb(base64.StdEncoding.EncodeToString(cipherText))
}
```

Вроде бы и там и там создали AES шифровальщик, а потом пошли непонятные `NewGCM` и `NewCBCEncrypter`… Что за GCM, что за CBC?? Это называется **режим работы блочного шифра**. Сейчас объясню.
